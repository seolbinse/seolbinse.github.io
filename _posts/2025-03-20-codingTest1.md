---
title: "[프로그래머스] 봉인된 주문 오답노트"
categories: algorithm
tags: c++
toc: true
author_profile: false
sidebar:
    nav: "docs"
search: true
use_math: true
---

## 첫 코테

이번에 대학 동아리에 들어가고, 코딩 테스트를 풀게 되었다.

호기롭게 프로그래머스 3단계에 도전하고 크게 꺾인 뒤, 

이 오답노트를 작성한다.

## 문제

주문 어쩌구 뭐가 말이 많은데, 요약하면 이렇다.

- 특정 규칙으로 나열된 문자열들이 있다.

- 그 문자열들에서 입력한 문자열 배열에 포함된 문자열을 제한다.

- 이렇게 제한 문자열에서 입력한 정수 번째에 올 문자열은 무엇일까?

특정 규칙이란 a부터 z까지, z 다음에는 aa, ab이고, zz 다음에는 aaa.....

이렇게 이어지는 알파벳, 즉 26진수다.

여기서 입력한 문자열 배열이 만약 a, b이고,

입력한 숫자가 4라면

a, b, c, d, e, f...... 에서

a와 b를 제한 문자열들의 4번째 문자 즉,

c, d, e, f.... 이니 출력은 f가 된다.

일단 내가 처음에 풀어본 풀이를 보자.


## Solve_1

```c++
#include <string>
#include <vector>

using namespace std;

string solution(long long n, vector<string> bans) 
{
    string answer; // 정답을 입력할 문자열

    vector<short> numArray; // 가상 26진수로 사용할 배열
    numArray.resize(n / 26 + 1); // 배열의 크기 정의

    int numCount = 1; // 알파벳 자릿수
    int ascii = 96; // 매직넘버 지양용

    // 소문자 a는 97이나 가상 26진수의 비어있는 자리를 구분하기 위해 
    // 0을 1로 사용했기에 기본적으로 1을 뺌

    for (int num = 0; num < n; num++) // 입력된 정수만큼 반복문
    {
        for (int i = 0, num1 = 0; i < 1; i++) // 1번만 실행하는 for문
        { // num1은 현재 
            if (numArray[num1] >= 26) // 현재 자릿수가 26일 때,
            {
                numArray[num1] = 1; // 그 배열의 숫자를 1로 바꾸고,
                i--; // 반복문 반복을 위해 조건문의 숫자 i를 빼 줌
                num1++; // 다음 자릿수 검사로 넘어감
                if (num1 + 1 > answer.length()) 
                { // 만약 문자열의 길이보다 현재 검사할 자릿수의 길이가 더 길다면,
                    numCount++; // 자릿수 변수에 1을 더함
                }
                continue; // 현재 자릿수가 26일 수도 있으니 컨티뉴로 넘어감
                // (근데 반복문 조건은 이상이라 의미 없음)
            }

            numArray[num1]++; // 1번만 반복할 시, 현재 자릿수에 1을 더하기
        }
        answer.clear(); // 이전에 입력한 값을 전부 지움

        for (int i = numCount - 1; i > -1; i--) // 자릿수만큼 반복
        { // 문자열 입력의 순서가 앞자리부터이기에 반복문의 조건을 자릿수로 시작함
            answer += char(ascii + numArray[i]);
            // 현재 자릿수에 해당하는 가상 26진수 배열의 원소에서 값을 가져와
            // 아스키코드를 대입해 문자열에 값을 추가함
        }

        for (int i = 0; i < bans.size(); i++) 
        { // 제외 문자열 검사
            if (answer == bans[i])
            {
                num--;
                // 제외할 문자열과 완성된 문자열이 일치하면 for문을 1번 더 반복
            }
        }
    }

    return answer; // 전체 for 문이 다 끝나고 나면 출력과 일치하는 문자열이 남는다
}
```

뭔가 벌써 개판이다.....

변수 이름은 정답 맞추고 고쳐야지 했는데 결국 못 고쳤다.

일단 문제를 차근차근 짚어보자.

## 분석_1

일단 이 코드의 작동 방식은 이러하다.

- 정수 배열을 가상 26진수로 생각한다.

- 배열의 0번째 인덱스가 26이라면 0으로 만들고 다음 인덱스에 1을 더한다.

- 이렇게 1을 더한 다음 인덱스도 26이라면 그 인덱스를 0으로 만들고 다음 인덱스를 검사한다.

- 다음 26진수를 구했다면 이를 아스키코드에 대입해 문자열을 생성한다.

- 해당 문자열이 제외 문자열 배열의 원소와 겹치면, 전체 반복문에서 1을 빼 한번 더 반복한다.

- 이하 반복, 반복문이 끝난다면 제외할 문자열들을 제외했을 때 n번째 오는 문자열이 남는다.

이러한 구조이다.



우선 for 문이 너무 많다.......

```c++
for (int num = 0; num < n; num++) // 입력값에 따라서 일정하게 늘어나는 선형 구조
{ // O(n)
    for (int i = 0, num1 = 0; i < 1; i++) // 특정 상황에서만 연산량이 늘어났다가 줄어드는 구조
    { // 대부분의 연산이 O(1)

    }

    for (int i = numCount - 1; i > -1; i--) // 계속 늘어나지만 특정 조건에서만 연산량이 증가하는 로그 구조
    { // O(logn)

    }

    for (int i = 0; i < bans.size(); i++) // 입력값에 따라서 일정하게 늘어나는 선형 구조 
    { // O(m) 맨 위와 표기가 겹치기에 일시적으로 m이라 표현

    }
}
```

BigO 표기법으로 정리하면 이러하다.

그러니 총 시간 복잡도는 O(n * logn * m)이 되는데,

코테에서는 10만을 넘어가는 입력도 테스트하기에 적절한 복잡도는 아니다.

특정 상황에서는 늘어나기도 하고.....

우선 시간 복잡도부터 줄여보자.